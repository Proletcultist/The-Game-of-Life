\chapter*{Software}
\addcontentsline{toc}{chapter}{Software}

\section*{Memory layout}
\addcontentsline{toc}{section}{Memory layout}

\begin{itemize}
	\item 0x0000 - 0x0080 - IVT
	\item 0xfc56 - SP initial value
	\item 0xfc56 - 0xfee0 - templates array 
	\item 0xfee1 - 0xfeff - input buffer 
	\item 0xff00-0xffff - I/O devices address space \begin{itemize}
		\item 0xff76 - address for triggering one game tick
		\item 0xff78 - address for controlling of interrupts throwing from UART controller
		\item 0xff7a - UART controller (for reading and writing data via UART) 
		\item 0xff7c - matrix controller state register №2 \begin{itemize}
				\item Bits 0-8 - bit string, representing born rule
				\item Bit 9 - play
				\item Bit 10 - reset (write 1 to this bit, to reset field)
				\item Bits 11-12 - speed
		\end{itemize}
		\item 0xff7e - matrix controller state register №1 \begin{itemize}
				\item Bits 0-8 - bit string, representing survive rule
		\end{itemize}
		\item 0xff80-0xffff - game field (for reading and writing of current field state 16 bits at a time) 
	\end{itemize}
\end{itemize}

\section*{Start section}
\addcontentsline{toc}{section}{Start section}

\begin{lstlisting}
main: ext
rsect start
start>
        ldi r0, 0xfc56
        stsp r0
        jsr main
        halt
end
\end{lstlisting}

Start section with start function in it stays for preparing runtime (setting SP initial value) and calling main function.

\section*{Matrix driver}
\addcontentsline{toc}{section}{Matrix driver}

Functions:

\begin{enumerate}
	\item setTo1
		\begin{itemize}
			\item Arguments: \textbf{r0} - $x$, \textbf{r1} - $y$. Coordinates should be in range 0-31.
			\item Sets cell with coordinates $(x, y)$ to alive status
		\end{itemize}
	\item setTo0
		\begin{itemize}
			\item Arguments: \textbf{r0} - $x$, \textbf{r1} - $y$. Coordinates should be in range 0-31.
			\item Sets cell with coordinates $(x, y)$ to dead status
		\end{itemize}
	\item invert
		\begin{itemize}
			\item Arguments: \textbf{r0} - $x$, \textbf{r1} - $y$. Coordinates should be in range 0-31.
			\item Inverts cell status with coordinates $(x, y)$
		\end{itemize}
	\item setRectTo1
		\begin{itemize}
			\item Arguments: \textbf{r0} - $x_{1}$, \textbf{r1} - $y_{1}$, \textbf{r2} - $x_{2}$, \textbf{r3} - $y_{2}$. Coordinates should be in range 0-31 and $x_{1} \leq x_{2}$, $y_{1} \leq y_{2}$.
			\item Sets all cells in rectangle with upper left corner ($x_{1}$, $y_{1}$) and lower right corner ($x_{2}$, $y_{2}$) to alive status
		\end{itemize}
	\item setRectTo0
		\begin{itemize}
			\item Arguments: \textbf{r0} - $x_{1}$, \textbf{r1} - $y_{1}$, \textbf{r2} - $x_{2}$, \textbf{r3} - $y_{2}$. Coordinates should be in range 0-31 and $x1 \leq x2$, $y1 \leq y2$.
			\item Sets all cells in rectangle with upper left corner ($x_{1}$, $y_{1}$) and lower right corner ($x_{2}$, $y_{2}$) to dead status
		\end{itemize}
	\item startGame
		\begin{itemize}
			\item Starts game
		\end{itemize}
	\item pauseGame
		\begin{itemize}
			\item Pauses game
		\end{itemize}
	\item setSurv
		\begin{itemize}
			\item Arguments: \textbf{r0} - bit string, representing survival rule. If bit number n (0-9) is 1, then alive cell with n alive neighbours will survive, otherwise it will die. All bits from 10th to 15th should be 0.
			\item Sets rule "survive"
		\end{itemize}
	\item setBorn
		\begin{itemize}
			\item Arguments: \textbf{r0} - bit string, representing born rule. If bit number n (0-9) is 1, then dead cell with n alive neighbours will becom alive, otherwise it remain dead. All bits from 10th to 15th should be 0.
			\item Sets rule "born"
		\end{itemize}
	\item clear
		\begin{itemize}
			\item Cleares game field
		\end{itemize}
	\item speedDown
		\begin{itemize}
			\item Increments speed, which causes slowdown (because 0 - the fastest speed). If speed is 3, it will change to 0
		\end{itemize}
	\item speedUp
		\begin{itemize}
			\item Decrements speed, which causes speed increae (because 0 - the fastest speed). If speed is 0, it will change to 3
		\end{itemize}
	\item setSpeed
		\begin{itemize}
			\item Arguments: \textbf{r0} - speed value. Bits 0-1 - speed value, other bits should be 0.
			\item Sets speed to specified value
		\end{itemize}
	\item stepOnce
		\begin{itemize}
			\item Do one iteration of game
		\end{itemize}
	\item insertTemplate
		\begin{itemize}
			\item Arguments: \textbf{r0} - slot number, \textbf{r1} - $x$, \textbf{r2} - $y$. Coordinates should be in range 0-31.
			\item Inserts template from specified slot, corrdinates $x$, $y$ specify upper left corner of inserted template.
		\end{itemize}
	\item saveTemplate
		\begin{itemize}
			\item Arguments: \textbf{r0} - slot number, \textbf{r1} - $x_{1}$, \textbf{r2} - $y_{1}$, \textbf{r3} - $x_{2}$, \textbf{r4} - $y_{2}$.
			\item Saves area with upper left corner $(x_{1}, y_{1})$ and lower right corner $(x_{2}, y_{2})$ as template to specified slot.
		\end{itemize}
\end{enumerate}

\subsection*{Matrix templates}
\addcontentsline{toc}{subsection}{Matrix templates}

Template is a saved part of game field. It represented as size of template and stream if bits, which represent states of saved cells. There is 5 templates in templates array.

Template structure:

\begin{itemize}
	\item 1 word - header
		\begin{itemize}
			\item bits 0 - 4 - width
			\item bits 5 - 9 - height
		\end{itemize}
	\item Following 64 words - template
\end{itemize}

\section*{Interrupt handlers}
\addcontentsline{toc}{section}{Interrupt handlers}

\section*{Main section}
\addcontentsline{toc}{section}{Main section}

\section*{Commands list}
\addcontentsline{toc}{section}{Commands list}

\begin{enumerate}
	\item \textsf{h} - print help message
	\item \textsf{s1 $x$ $y$} - set cell $(x, y)$ to alive status
	\item \textsf{s0 $x$ $y$} - set cell $(x, y)$ to dead status
	\item \textsf{i $x$ $y$} - invert status of $(x, y)$ cell
	\item \textsf{play} - run game
	\item \textsf{pause} - stop game
	\item \textsf{step} - make one iteration of game
	\item \textsf{rules S$<$digits sequence$>$B$<$digits sequence$>$} - set rules
	\item \textsf{su} - speed up
	\item \textsf{sd} - speed down
	\item \textsf{ss $n$} - set speed to value $n$
	\item \textsf{S1 $x_{1}$ $y_{1}$ $x_{2}$ $y_{2}$} -  Sets all cells in rectangle with upper left corner ($x_{1}$, $y_{1}$) and lower right corner ($x_{2}$, $y_{2}$) to alive status
	\item \textsf{S0 $x_{1}$ $y_{1}$ $x_{2}$ $y_{2}$} -  Sets all cells in rectangle with upper left corner ($x_{1}$, $y_{1}$) and lower right corner ($x_{2}$, $y_{2}$) to dead status
	\item \textsf{save $n$ $x_{1}$ $y_{1}$ $x_{2}$ $y_{2}$} - Save all cells in rectangle with upper left corner ($x_{1}$, $y_{1}$) and lower right corner ($x_{2}$, $y_{2}$) to slot number $n$.
	\item \textsf{load $n$ $x$ $y$} - Copy all cells from slot $n$ to rectangle with upper left corner ($x_{1}$, $y_{1}$)
\end{enumerate}

\section*{Commands parsing}
\addcontentsline{toc}{section}{Commands parsing}

Functions:

\begin{enumerate}
	\item \textbf{skipSpaces}
		\begin{itemize}
			\item Argument: r0 - pointer to buffer's symbol
			\item Skips all spaces from current symbol
		\end{itemize}
\item \textbf{strncmp}
	\begin{itemize}
		\item Arguments: r0 - pointer to buffer's symbol, r1 - pointer to command's symbol, r4 - number of symbols
		\item Compares the first n symbols from the current symbol with a command of size n
	\end{itemize}
\item \textbf{readUInt}
	\begin{itemize}
		\item Arguments: r0 - pointer to buffer's symbol
		\item Gets a number from the buffer from the current symbol
	\end{itemize}
\end{enumerate}

General algorithm for parsing:

\begin{itemize}
	\item Call the skipSpaces function
	\item Compare with the command using strncmp
	\item Call skipSpaces again
	\item Then call skipSpaces and readUInt as needed
\end{itemize}
